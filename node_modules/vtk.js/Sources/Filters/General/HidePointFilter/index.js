import macro from 'vtk.js/Sources/macro';
import vtkPolyData from 'vtk.js/Sources/Common/DataModel/PolyData';
import vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';
import vtkPoints from 'vtk.js/Sources/Common/Core/Points';

const {
    vtkErrorMacro
} = macro;

function removeCell3(input, cropped, points) {
    // renvoie un array sans les vert/line/poly/strip qui contiennent les points à enlever en prenant en compte les changements d'indice
    if (input.length === 0) {
        return input;
    }

    var jump = input[0];
    var index = 0;

    const reducer = (accumulator, currentValue) => accumulator &&
        (!cropped.includes(currentValue));

    // change toutes les cellules coupées en [-1,...,-1] pour l'empêcher de chercher des points particulier
    while (index < input.length) {
        if (!input.slice(index + 1, index + jump + 1).reduce(reducer, true)) {
            input.fill(-1, index, index, jump + 1);
        }
        index += (jump + 1);
        jump = input[index];
    }

    return new Float32Array(input);
}

// ----------------------------------------------------------------------------
// vtkHidePointFilter methods for XMLPolyData with scalars
// ----------------------------------------------------------------------------

function vtkHidePointFilter(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkHidePointFilter');

    publicAPI.requestData = (inData, outData) => {
        // implement requestData
        const input = inData[0];

        if (!input) {
            vtkErrorMacro('Invalid or missing input');
            return;
        }

        const scalars = input.getPointData().getScalars();
        const scalarsData = scalars.getData();

        if (!scalars) {
            vtkErrorMacro('No scalars from input');
            return;
        }

        // Allocate output
        const output = vtkPolyData.newInstance();

        const bounds = input.getBounds();
        const points = input.getPoints();
        const arrayPoints = points.getData();
        var numPts = points.getNumberOfTuples();

        if (model.removePoints[0] === []) {
            outData[0] = input;
            console.log("exit");
            return;
        }

        const cropped = model.removePoints[0];

        const pointsvtk = vtkPoints.newInstance({
            dataType: points.getDataType(),
        });

        pointsvtk.setData(arrayPoints, numPts);
        pointsvtk.setNumberOfPoints(numPts);

        var coordPoint = [];

        // bloc permettant de ne garder que les points nécessaires
        for (var i = 0, l = arrayPoints.length / 3; i < l; i++) {
            coordPoint = points.getPoint(i);
            if (!cropped.includes(i)) {
                pointsvtk.setPoint(i, coordPoint[0], coordPoint[1], coordPoint[2]);
            } else {
                // change les coordonnées des points coupés en string pour l'empêcher d'avoir des coordonnées réelles accessibles 
                pointsvtk.setPoint(i, "a", "a", "a");
            }
        }

        const croppedScalars = vtkDataArray.newInstance({
            name: scalars.getName(),
            values: pointsvtk.getData(),
            numberOfTuples: numPts,
            numberOfComponents: scalars.getNumberOfComponents(),
            size: numPts * scalars.getNumberOfComponents(),
        });

        //pointsvtk.setData(numPts);

        output.setPoints(pointsvtk);

        output.getVerts().setData(removeCell3(Array.from(input.getVerts().getData()), cropped, points));
        output.getLines().setData(removeCell3(Array.from(input.getLines().getData()), cropped, points));
        output.getStrips().setData(removeCell3(Array.from(input.getStrips().getData()), cropped, points));
        output.getPolys().setData(removeCell3(Array.from(input.getPolys().getData()), cropped, points));
        output.getPointData().setScalars(croppedScalars);

        outData[0] = output;
    };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
    removePoints: [],
};

// ----------------------------------------------------------------------------

export function extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, DEFAULT_VALUES, initialValues);

    // Make this a VTK object
    macro.obj(publicAPI, model);

    // Also make it an algorithm with one input and one output
    macro.algo(publicAPI, model, 1, 1);

    // no orientation support yet / A modifier !!!!!
    macro.setGetArray(publicAPI, model, ['removePoints'], 1);

    // Object specific methods
    vtkHidePointFilter(publicAPI, model);
}

// ----------------------------------------------------------------------------

export const newInstance = macro.newInstance(extend, 'vtkHidePointFilter');

// ----------------------------------------------------------------------------

export default {
    newInstance,
    extend
};
