import macro from 'vtk.js/Sources/macro';
import vtkPolyData from 'vtk.js/Sources/Common/DataModel/PolyData';
import vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';
import vtkPoints from 'vtk.js/Sources/Common/Core/Points';

const {
    vtkErrorMacro
} = macro;

// ----------------------------------------------------------------------------
// vtkPolyDataMoveSetFilter methods for XMLPolyData with scalars
// ----------------------------------------------------------------------------

function vtkPolyDataMoveSetFilter(publicAPI, model) {

    // Set our className
    model.classHierarchy.push('vtkPolyDataMoveSetFilter');

    publicAPI.requestData = (inData, outData) => {
        // implement requestData
        const input = inData[0];

        if (!input) {
            vtkErrorMacro('Invalid or missing input');
            return;
        }

        // Allocate output
        const output = vtkPolyData.newInstance();

        const bounds = input.getBounds();
        const points = input.getPoints();
        const arrayPoints = points.getData();
        var numPts = points.getNumberOfTuples();

        const moveArray = model.move[0];

        const elementsArray = model.move[1];

        if (moveArray.length == 0 || elementsArray.length == 0) {
            const sameAsInput = vtkPolyData.newInstance();
            sameAsInput.shallowCopy(input);
            outData[0] = sameAsInput;
            return;
        }

        const pointsvtk = vtkPoints.newInstance({
            dataType: points.getDataType(),
        });

        pointsvtk.setData(arrayPoints, numPts);
        pointsvtk.setNumberOfPoints(numPts);

        let pointCoords = [];

        /*        // create every points
                for (let i = 0; i < arrayPoints.length / 3; i++) {
                    pointCoords = points.getPoint(i);
                    pointsvtk.setPoint(i, pointCoords[0], pointCoords[1], pointCoords[2]);
                }*/

        let l = 0;

        // change the coords
        for (let j = 0; j < elementsArray.length; j++) {
            l = elementsArray[j].length;
            for (let i = 0; i < l; i++) {
                pointCoords = points.getPoint(elementsArray[j][i]);
                if (!isNaN(pointCoords[0] + moveArray[j * 3 + 0]) && !isNaN(pointCoords[1] + moveArray[j * 3 + 1]) && !isNaN(pointCoords[2] + moveArray[j * 3 + 2])) {
                    /*if (isNaN(pointCoords[0] + moveArray[j * 3 + 0]) || isNaN(pointCoords[1] + moveArray[j * 3 + 1]) || isNaN(pointCoords[2] + moveArray[j * 3 + 2])) {
    console.log(pointCoords[0]);
    console.log(moveArray[j * 3 + 0]);
    console.log(pointCoords[1]);
    console.log(moveArray[j * 3 + 1]);
    console.log(pointCoords[2]);
    console.log(moveArray[j * 3 + 2]);
}*/
                    pointsvtk.setPoint(elementsArray[j][i], Number(pointCoords[0] + moveArray[j * 3 + 0]), Number(pointCoords[1] + moveArray[j * 3 + 1]), Number(pointCoords[2] + moveArray[j * 3 + 2]));
                } else {
                    console.log(pointCoords[0]);
                    pointsvtk.setPoint(elementsArray[j][i], pointCoords[0], pointCoords[1], pointCoords[2]);
                }
            }
        }

        const scalars = input.getPointData().getScalars();
        if (scalars) {

            const scalarsData = scalars.getData();

            const croppedScalars = vtkDataArray.newInstance({
                name: scalars.getName(),
                values: pointsvtk.getData(),
                numberOfTuples: numPts,
                numberOfComponents: scalars.getNumberOfComponents(),
                size: numPts * scalars.getNumberOfComponents(),
            });
            output.getPointData().setScalars(croppedScalars);
        }

        output.setPoints(pointsvtk);

        output.getVerts().setData(input.getVerts().getData());
        output.getLines().setData(input.getLines().getData());
        output.getStrips().setData(input.getStrips().getData());
        output.getPolys().setData(input.getPolys().getData());

        outData[0] = output;
    };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
    move: [[], []],
};

// ----------------------------------------------------------------------------

export function extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, DEFAULT_VALUES, initialValues);

    // Make this a VTK object
    macro.obj(publicAPI, model);

    // Also make it an algorithm with one input and one output
    macro.algo(publicAPI, model, 1, 1);

    macro.setGetArray(publicAPI, model, ['move'], 2);

    // Object specific methods
    vtkPolyDataMoveSetFilter(publicAPI, model);
}

// ----------------------------------------------------------------------------

export const newInstance = macro.newInstance(extend, 'vtkPolyDataMoveSetFilter');

// ----------------------------------------------------------------------------

export default {
    newInstance,
    extend
};
