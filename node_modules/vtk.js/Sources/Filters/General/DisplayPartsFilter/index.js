import macro from 'vtk.js/Sources/macro';
import vtkPolyData from 'vtk.js/Sources/Common/DataModel/PolyData';
import vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';
import vtkPoints from 'vtk.js/Sources/Common/Core/Points';

import GPU, {
    input
} from 'gpu.js';

const {
    vtkErrorMacro
} = macro;

const gpu = new GPU();

function keepCells(input, keptPoints) {
    // renvoie un array sans les vert/line/poly/strip qui contiennent les points à enlever en prenant en compte les changements d'indice
    if (input.length === 0) {
        return input;
    }

    var jump = input[0];
    var index = 0;






    /*    // ----------------------------------------------------------------------------
        // GPU computations
        // ----------------------------------------------------------------------------

        const reduceInput = gpu.createKernel(function (array, keptPoints, jump) {
            if (this.thread.x % jump === 0 || array[this.thread.x] === -1) {
                return array[this.thread.x];
            } else if (array[this.thread.x] === keptPoints[this.thread.y]) {
                return -1;
            } else {
                return array[this.thread.x];
            }
        }).setOutput([input.length]).setLoopMaxIterations(1);

        const confirm = gpu.createKernel(function (array, jump) {
            if (this.thread.x % jump === 0) {
                return array[this.thread.x];
            }
            if (jump === 2) {
                if (this.thread.x % jump === 1 && array[this.thread.x + 1] === -1) {
                    return -1;
                } else if (this.thread.x % jump === 2 && array[this.thread.x - 1] === -1) {
                    return -1;
                } else {
                    return array[this.thread.x];
                }
            } else if (jump === 3) {
                if (this.thread.x % jump === 1 && (array[this.thread.x + 1] === -1 || array[this.thread.x + 2] === -1)) {
                    return -1;
                } else if (this.thread.x % jump === 2 && (array[this.thread.x + 1] === -1 || array[this.thread.x - 1] === -1)) {
                    return -1;
                } else if (this.thread.x % jump === 3 && (array[this.thread.x - 1] === -1 || array[this.thread.x - 2] === -1)) {
                    return -1;
                } else {
                    return array[this.thread.x];
                }
            } else {
                return array[this.thread.x];
            }
        }).setOutput([input.length]).setLoopMaxIterations(1);

        return new Float32Array(confirm(reduceInput(input, keptPoints, input[0]), input[0]));*/




    const reducer = (accumulator, currentValue) => accumulator && keptPoints.includes(currentValue);

    // change toutes les cellules coupées en [-1,...,-1] pour l'empêcher de chercher des points particulier
    while (index < input.length) {
        if (!input.slice(index + 1, index + jump + 1).reduce(reducer, true)) {
            input.fill(-1, index, index, jump + 1);
        }
        index += (jump + 1);
        jump = input[index];
    }

    return new Float32Array(input);
}

// ----------------------------------------------------------------------------
// vtkDisplayPartsFilter methods for XMLPolyData with scalars
// ----------------------------------------------------------------------------

function vtkDisplayPartsFilter(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkDisplayPartsFilter');

    publicAPI.requestData = (inData, outData) => {
        // implement requestData
        const input = inData[0];

        if (!input) {
            vtkErrorMacro('Invalid or missing input');
            return;
        }

        // Allocate output
        const output = vtkPolyData.newInstance();

        const bounds = input.getBounds();
        const points = input.getPoints();
        const arrayPoints = points.getData();
        const maxi = Math.max(arrayPoints);
        var numPts = points.getNumberOfTuples();

        const keptPoints = model.keptPoints;

        if (keptPoints.length == 0 || keptPoints.length >= (arrayPoints.length / 3)) {
            const sameAsInput = vtkPolyData.newInstance();
            sameAsInput.shallowCopy(input);
            outData[0] = sameAsInput;
            return;
        }

        const pointsvtk = vtkPoints.newInstance({
            dataType: points.getDataType(),
        });

        pointsvtk.setNumberOfPoints(numPts);

        var coordPoint = [];

/*        // ----------------------------------------------------------------------------
        // GPU computations
        // ----------------------------------------------------------------------------

        const myFunc = gpu.createKernel(function (array, keptPoints, maxi) {
            if (this.thread.x === keptPoints[this.thread.y]) {
                return array[this.thread.x];
            }
            return maxi;
        }).setOutput([arrayPoints.length]).setLoopMaxIterations(1);

        const confirm = gpu.createKernel(function (array, maxi) {
            if (this.thread.x % 3 === 0 && (array[this.thread.x + 1] === maxi || array[this.thread.x + 2] === maxi)) {
                return maxi;
            } else if (this.thread.x % 3 === 1 && (array[this.thread.x + 1] === maxi || array[this.thread.x - 1] === maxi)) {
                return maxi;
            } else if (this.thread.x % 3 === 2 && (array[this.thread.x - 1] === maxi || array[this.thread.x - 2] === maxi)) {
                return maxi;
            } else {
                return array[this.thread.x];
            }
        }).setOutput([arrayPoints.length]).setLoopMaxIterations(1);

        console.log(myFunc(arrayPoints.slice(0, arrayPoints.length / 4), keptPoints, maxi));

        const dataPoints1 = confirm(myFunc(arrayPoints.slice(0, arrayPoints.length / 4), keptPoints, maxi), maxi);
        const dataPoints2 = confirm(myFunc(arrayPoints.slice(arrayPoints.length / 4, arrayPoints.length / 2), keptPoints, maxi), maxi);
        const dataPoints3 = confirm(myFunc(arrayPoints.slice(arrayPoints.length / 2, 3 * arrayPoints.length / 4), keptPoints, maxi), maxi);
        const dataPoints4 = confirm(myFunc(arrayPoints.slice(3 * arrayPoints.length / 4, arrayPoints.length + 1), keptPoints, maxi), maxi);
        const dataPoints = dataPoints1.concat(dataPoints2.concat(dataPoints3.concat(dataPoints4)));

        pointsvtk.setData(dataPoints, 3);*/



        // Bloc CPU
        // bloc permettant de ne garder que les points nécessaires
        for (var i = 0, l = arrayPoints.length / 3; i < l; i++) {
            coordPoint = points.getPoint(i);

            if (keptPoints.includes(i)) {
                pointsvtk.setPoint(i, coordPoint[0], coordPoint[1], coordPoint[2]);
            } else {
                // Change coords of the cut points to NaN so they are unavailable
                pointsvtk.setPoint(i, "a", "a", "a");
            }
        }

        const scalars = input.getPointData().getScalars();

        if (scalars) {
            const scalarsData = scalars.getData();

            const croppedScalars = vtkDataArray.newInstance({
                name: scalars.getName(),
                values: pointsvtk.getData(),
                numberOfTuples: numPts,
                numberOfComponents: scalars.getNumberOfComponents(),
                size: numPts * scalars.getNumberOfComponents(),
            });
            output.getPointData().setScalars(croppedScalars);
        }

        output.setPoints(pointsvtk);

        output.getVerts().setData(keepCells(Array.from(input.getVerts().getData()), keptPoints));
        output.getLines().setData(keepCells(Array.from(input.getLines().getData()), keptPoints));
        output.getStrips().setData(keepCells(Array.from(input.getStrips().getData()), keptPoints));
        output.getPolys().setData(keepCells(Array.from(input.getPolys().getData()), keptPoints));

        outData[0] = output;
    };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
    keptPoints: [],
};

// ----------------------------------------------------------------------------

export function extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, DEFAULT_VALUES, initialValues);

    // Make this a VTK object
    macro.obj(publicAPI, model);

    // Also make it an algorithm with one input and one output
    macro.algo(publicAPI, model, 1, 1);

    // no orientation support yet
    macro.setGet(publicAPI, model, ['keptPoints']);

    // Object specific methods
    vtkDisplayPartsFilter(publicAPI, model);
}

// ----------------------------------------------------------------------------

export const newInstance = macro.newInstance(extend, 'vtkDisplayPartsFilter');

// ----------------------------------------------------------------------------

export default {
    newInstance,
    extend
};
