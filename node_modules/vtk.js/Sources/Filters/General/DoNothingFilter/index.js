import macro from 'vtk.js/Sources/macro';
import vtkPolyData from 'vtk.js/Sources/Common/DataModel/PolyData';
import vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';
import vtkPoints from 'vtk.js/Sources/Common/Core/Points';

const {
    vtkErrorMacro
} = macro;

// ----------------------------------------------------------------------------
// vtkDoNothingFilter methods for XMLPolyData with scalars
// ----------------------------------------------------------------------------

function vtkDoNothingFilter(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkDoNothingFilter');

    publicAPI.requestData = (inData, outData) => {
        // implement requestData
        const input = inData[0];

        if (!input) {
            vtkErrorMacro('Invalid or missing input');
            return;
        }

        // Allocate output
        const output = vtkPolyData.newInstance();

        const bounds = input.getBounds();
        const points = input.getPoints();
        const arrayPoints = points.getData();
        var numPts = points.getNumberOfTuples();

        const shifting = model.shifting;

        if (shifting === 0) {
            const sameAsInput = vtkPolyData.newInstance();
            sameAsInput.shallowCopy(input);
            outData[0] = sameAsInput;
            return;
        }

        const pointsvtk = vtkPoints.newInstance({
            dataType: points.getDataType(),
        });

        pointsvtk.setData(arrayPoints, numPts);
        pointsvtk.setNumberOfPoints(numPts);

        var coordPoint = [];

        // bloc permettant de ne garder que les points n√©cessaires
        for (var i = 0, l = arrayPoints.length / 3; i < l; i++) {
            coordPoint = points.getPoint(i);
            pointsvtk.setPoint(i, coordPoint[0] + shifting, coordPoint[1] + shifting, coordPoint[2] + shifting);
        }

        const scalars = input.getPointData().getScalars();
        if (scalars) {

            const scalarsData = scalars.getData();

            const croppedScalars = vtkDataArray.newInstance({
                name: scalars.getName(),
                values: pointsvtk.getData(),
                numberOfTuples: numPts,
                numberOfComponents: scalars.getNumberOfComponents(),
                size: numPts * scalars.getNumberOfComponents(),
            });
            output.getPointData().setScalars(croppedScalars);
        }

        //pointsvtk.setData(numPts);

        output.setPoints(pointsvtk);

        output.getVerts().setData(input.getVerts().getData());
        output.getLines().setData(input.getLines().getData());
        output.getStrips().setData(input.getStrips().getData());
        output.getPolys().setData(input.getPolys().getData());

        outData[0] = output;
    };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
    shifting: 0,
};

// ----------------------------------------------------------------------------

export function extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, DEFAULT_VALUES, initialValues);

    // Make this a VTK object
    macro.obj(publicAPI, model);

    // Also make it an algorithm with one input and one output
    macro.algo(publicAPI, model, 1, 1);

    // no orientation support yet
    macro.setGet(publicAPI, model, ['shifting']);

    // Object specific methods
    vtkDoNothingFilter(publicAPI, model);
}

// ----------------------------------------------------------------------------

export const newInstance = macro.newInstance(extend, 'vtkDoNothingFilter');

// ----------------------------------------------------------------------------

export default {
    newInstance,
    extend
};
