import macro from 'vtk.js/Sources/macro';
import vtkPolyData from 'vtk.js/Sources/Common/DataModel/PolyData';
import vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';
import vtkPoints from 'vtk.js/Sources/Common/Core/Points';

const {
    vtkErrorMacro
} = macro;

function removeCell3(inputPoints, cropped, points) {
    // renvoie un array sans les vert/line/poly/strip qui contiennent les points à enlever en prenant en compte les changements d'indice
    if (inputPoints.length === 0) {
        return inputPoints;
    }

    let jump = inputPoints[0];
    let index = 0;

    const reducer = (accumulator, currentValue) => accumulator &&
        (cropped[0] <= points.getPoint(currentValue)[0]) &&
        (cropped[1] >= points.getPoint(currentValue)[0]) &&
        (cropped[2] <= points.getPoint(currentValue)[1]) &&
        (cropped[3] >= points.getPoint(currentValue)[1]) &&
        (cropped[4] <= points.getPoint(currentValue)[2]) &&
        (cropped[5] >= points.getPoint(currentValue)[2]);

    // change toutes les cellules coupées en [-1,...,-1] pour l'empêcher de chercher des points particulier
    while (index < inputPoints.length) {
        if (!inputPoints.slice(index + 1, index + jump + 1).reduce(reducer, true)) {
            inputPoints.fill(-1, index, index, jump + 1);
        }
        index += (jump + 1);
        jump = inputPoints[index];
    }

    return Uint32Array.from(inputPoints);
}

// ----------------------------------------------------------------------------
// vtkPolyDataRegularCropFilter methods for XMLPolyData with scalars
// ----------------------------------------------------------------------------

function vtkPolyDataRegularCropFilter(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkPolyDataRegularCropFilter');

    publicAPI.requestData = (inData, outData) => {
        // implement requestData
        const input = inData[0];

        if (!input) {
            vtkErrorMacro('Invalid or missing input');
            return;
        }

        // Allocate output
        const output = vtkPolyData.newInstance();

        const bounds = input.getBounds();
        const points = input.getPoints();
        const arrayPoints = points.getData();
        let numPts = points.getNumberOfTuples();

        const cropped =
            model.croppingPlanes.length === 6 ?
            bounds.map((e, i) => {
                if (i % 2 === 0) {
                    // min plane
                    return Math.max(e, model.croppingPlanes[i]);
                }
                // max plane
                return Math.min(e, model.croppingPlanes[i]);
            }) :
            bounds;

        if (
            cropped[0] === bounds[0] &&
            cropped[1] === bounds[1] &&
            cropped[2] === bounds[2] &&
            cropped[3] === bounds[3] &&
            cropped[4] === bounds[4] &&
            cropped[5] === bounds[5]
        ) {
            const sameAsInput = vtkPolyData.newInstance();
            sameAsInput.shallowCopy(input);
            outData[0] = sameAsInput;
            return;
        }

        // reorder if needed
        for (let i = 0; i < 3; ++i) {
            if (cropped[i * 2] > cropped[i * 2 + 1]) {
        [cropped[i * 2], cropped[i * 2 + 1]] = [
          cropped[i * 2 + 1],
          cropped[i * 2],
        ];
            }
        }

        const pointsvtk = vtkPoints.newInstance({
            dataType: points.getDataType(),
        });

        //pointsvtk.setData(arrayPoints, numPts);
        pointsvtk.setNumberOfPoints(numPts);

        let coordPoint = [];

        // bloc permettant de ne garder que les points nécessaires
        for (let i = 0, l = arrayPoints.length / 3; i < l; i++) {
            coordPoint = points.getPoint(i);
            if (
                cropped[0] <= coordPoint[0] &&
                cropped[1] >= coordPoint[0] &&
                cropped[2] <= coordPoint[1] &&
                cropped[3] >= coordPoint[1] &&
                cropped[4] <= coordPoint[2] &&
                cropped[5] >= coordPoint[2]
            ) {
                pointsvtk.setPoint(i, coordPoint[0], coordPoint[1], coordPoint[2]);
            } else {
                // Change coords of the cut points to NaN so they are unavailable
                pointsvtk.setPoint(i, "a", "a", "a");
            }
        }

        const scalars = input.getPointData().getScalars();
        if (scalars) {

            const scalarsData = scalars.getData();

            const croppedScalars = vtkDataArray.newInstance({
                name: scalars.getName(),
                values: pointsvtk.getData(),
                numberOfTuples: numPts,
                numberOfComponents: scalars.getNumberOfComponents(),
                size: numPts * scalars.getNumberOfComponents(),
            });
            output.getPointData().setScalars(croppedScalars);
        }

        //pointsvtk.setData(numPts);

        output.setPoints(pointsvtk);

        output.getVerts().setData(removeCell3(Array.from(input.getVerts().getData()), cropped, points));
        output.getLines().setData(removeCell3(Array.from(input.getLines().getData()), cropped, points));
        output.getStrips().setData(removeCell3(Array.from(input.getStrips().getData()), cropped, points));
        output.getPolys().setData(removeCell3(Array.from(input.getPolys().getData()), cropped, points));

        outData[0] = output;
    };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
    croppingPlanes: [],
};

// ----------------------------------------------------------------------------

export function extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, DEFAULT_VALUES, initialValues);

    // Make this a VTK object
    macro.obj(publicAPI, model);

    // Also make it an algorithm with one input and one output
    macro.algo(publicAPI, model, 1, 1);

    // no orientation support yet
    macro.setGetArray(publicAPI, model, ['croppingPlanes'], 6);

    // Object specific methods
    vtkPolyDataRegularCropFilter(publicAPI, model);
}

// ----------------------------------------------------------------------------

export const newInstance = macro.newInstance(extend, 'vtkPolyDataRegularCropFilter');

// ----------------------------------------------------------------------------

export default {
    newInstance,
    extend
};
