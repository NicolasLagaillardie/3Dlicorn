import macro from 'vtk.js/Sources/macro';
import vtkPolyData from 'vtk.js/Sources/Common/DataModel/PolyData';
import vtkDataArray from 'vtk.js/Sources/Common/Core/DataArray';
import vtkPoints from 'vtk.js/Sources/Common/Core/Points';

const {
    vtkErrorMacro
} = macro;

function removeCell3(input, cropped, points) {
    // renvoie un array sans les vert/line/poly/strip qui contiennent les points à enlever en prenant en compte les changements d'indice
    if (input.length === 0) {
        return input;
    }

    var jump = input[0];
    var index = 0;

    //const test = input.map((e,i) => i%3 === 0 ? e === 2 ? true : false : true );

    //console.log(test.includes(false)) ;

    const reducer = (accumulator, currentValue) => accumulator &&
        (cropped[0] * (points.getPoint(currentValue)[0] - cropped[3]) + cropped[1] * (points.getPoint(currentValue)[1] - cropped[4]) + cropped[2] * (points.getPoint(currentValue)[2] - cropped[5]) >= 0);

    // change toutes les cellules coupées en [-1,...,-1] pour l'empêcher de chercher des points particulier
    while (index < input.length) {
        if (!input.slice(index + 1, index + jump + 1).reduce(reducer, true)) {
            input.fill(-1, index, index, jump + 1);
        }
        index += (jump + 1);
        jump = input[index];
    }

    return new Float32Array(input);
}

// ----------------------------------------------------------------------------
// vtkPolyDataCropFilter methods for XMLPolyData with scalars
// ----------------------------------------------------------------------------

function vtkPolyDataCropFilter(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkPolyDataCropFilter');

    publicAPI.requestData = (inData, outData) => {
        // implement requestData
        const input = inData[0];

        if (!input) {
            vtkErrorMacro('Invalid or missing input');
            return;
        }

        // Allocate output
        const output = vtkPolyData.newInstance();

        const bounds = input.getBounds();
        const points = input.getPoints();
        const arrayPoints = points.getData();
        var numPts = points.getNumberOfTuples();

        // cropping plane : coords normal vector then coord one point of the plane
        /*
        const cropped =
            model.croppingPlanes.length === 6 ?
            bounds.map((e, i) => {
                if (i % 2 === 0) {
                    // min plane
                    return Math.max(e, model.croppingPlanes[i]);
                }
                // max plane
                return Math.min(e, model.croppingPlanes[i]);
            }) :
            bounds;
        */
        const cropped = model.croppingPlane;

        if (cropped.length != 6) {
            const sameAsInput = vtkPolyData.newInstance();
            sameAsInput.shallowCopy(input);
            outData[0] = sameAsInput;
            return;
        }

        /*
        // reorder if needed
        for (let i = 0; i < 3; ++i) {
            if (cropped[i * 2] > cropped[i * 2 + 1]) {
        [cropped[i * 2], cropped[i * 2 + 1]] = [
          cropped[i * 2 + 1],
          cropped[i * 2],
        ];
            }
        }
        */

        const pointsvtk = vtkPoints.newInstance({
            dataType: points.getDataType(),
        });

        //pointsvtk.setData(arrayPoints, numPts);
        pointsvtk.setNumberOfPoints(numPts);

        var coordPoint = [];

        // bloc permettant de ne garder que les points nécessaires
        for (var i = 0, l = arrayPoints.length / 3; i < l; i++) {
            coordPoint = points.getPoint(i);
            if (cropped[0] * (coordPoint[0] - cropped[3]) + cropped[1] * (coordPoint[1] - cropped[4]) + cropped[2] * (coordPoint[2] - cropped[5]) >= 0) {
                pointsvtk.setPoint(i, coordPoint[0], coordPoint[1], coordPoint[2]);
            } else {
                // change les coordonnées des points coupés en string pour l'empêcher d'avoir des coordonnées réelles accessibles 
                pointsvtk.setPoint(i, "a", "a", "a");
            }
        }

        const scalars = input.getPointData().getScalars();

        if (scalars) {
            const scalarsData = scalars.getData();

            const croppedScalars = vtkDataArray.newInstance({
                name: scalars.getName(),
                values: pointsvtk.getData(),
                numberOfTuples: numPts,
                numberOfComponents: scalars.getNumberOfComponents(),
                size: numPts * scalars.getNumberOfComponents(),
            });
            output.getPointData().setScalars(croppedScalars);
        }

        //pointsvtk.setData(numPts);

        output.setPoints(pointsvtk);

        output.getVerts().setData(removeCell3(Array.from(input.getVerts().getData()), cropped, points));
        output.getLines().setData(removeCell3(Array.from(input.getLines().getData()), cropped, points));
        output.getStrips().setData(removeCell3(Array.from(input.getStrips().getData()), cropped, points));
        output.getPolys().setData(removeCell3(Array.from(input.getPolys().getData()), cropped, points));

        outData[0] = output;
    };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
    croppingPlane: [],
};

// ----------------------------------------------------------------------------

export function extend(publicAPI, model, initialValues = {}) {
    Object.assign(model, DEFAULT_VALUES, initialValues);

    // Make this a VTK object
    macro.obj(publicAPI, model);

    // Also make it an algorithm with one input and one output
    macro.algo(publicAPI, model, 1, 1);

    // no orientation support yet
    macro.setGetArray(publicAPI, model, ['croppingPlane'], 6);

    // Object specific methods
    vtkPolyDataCropFilter(publicAPI, model);
}

// ----------------------------------------------------------------------------

export const newInstance = macro.newInstance(extend, 'vtkPolyDataCropFilter');

// ----------------------------------------------------------------------------

export default {
    newInstance,
    extend
};
